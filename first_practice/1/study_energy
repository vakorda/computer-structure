.data
   stored_key: .string "password"
.text

# string_compare: a0, a1, a2,   ,   ,   ,   ,   ,   , t2, t3
# study_energy:   a0,   , a2, a3,   ,   ,   ,   , t1,
# loop_1:         a0,   ,   , a3,   ,   ,   , a7,   ,   ,   ,   , t5
# total:          a0, a1, a2, a3,   ,   ,   , a7, t1, t2, t3,   , t5

main:
    li a3 'a' # first char on the alphabet
    li t5 26 # number of letters on the alphabet
    
loop_1: beqz t5 end
	mv a0 a3 # print char
    li a7 11
    ecall
    
    # save char in the stack
    sb a3 0(sp)
    sb x0 1(sp)
    # go to next position in the stack
    addi sp sp -4
    
    jal ra study_energy # a3 = letter to study energy for -> a0
    
    li a7 1 # print cycles
    ecall
    li a7 11 # go to next line
    li a0 10
    ecall
    
    addi a3 a3 1 # next char
    addi t5 t5 -1 # lower counter
    j loop_1
    
end:li a7 10 # end
    ecall

study_energy:
	# save ra
    sw ra 0(sp)
    # go to prev position on the stack (word to study energy saved there)
    addi sp sp 4
    
    mv a2 sp
    rdcycle t1
    jal ra string_compare # a2 = Address1 -> a0
    rdcycle a0
    sub a0 a0 t1
    
    # restore previous ra
    lw ra -4(sp)
    addi sp sp -4
    jr ra


string_compare:
    la a1 stored_key #Argument 1 = saved password
    lbu t2 0(a1) # a = char11
    lbu t3 0(a2) # b = char12

buc1: beqz t2 try #if t2 is equal to 0, we check if t3 is also equal
    bne t2 t3 not_eq # if a[n] != b[n] -> not eq
    addi a1 a1 1 # Address1 + 1
    addi a2 a2 1 # Address2 + 1
    lbu t2 0(a1) # reset value of the addresses
    lbu t3 0(a2)
    j buc1

try: bnez t3 not_eq # and if t3 is also equal, both words have the same length so its the same word
	li a0 1 # its the same word, so 1
    jr ra
not_eq:
    li a0 0 # different words, so 0
    jr ra
